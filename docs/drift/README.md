# Drift Detection and Incremental Analysis

This folder contains a prototype implementation of mechanics to detect logical and semantic drift, and to perform incremental builds and test impact analysis.

## Components

- `src/drift/dependency-graph.ts` - module+file graph: add module deps, link files to modules, compute reverse closure.
- `src/drift/test-impact.ts` - test impact analyzer combining coverage and history.
- `src/drift/cache-key.ts` - functions to compute safe cache keys and normalized content.
- `src/lsp/semantic-drift.ts` - skeletal LSP diagnostic function for simple heuristic drift detection.
- `scripts/semgrep/semantic-drift-rules.yml` - example Semgrep rules to detect control-flow regressions.
- `.github/workflows/drift-check.yml` - CI workflow skeleton with lint, unit tests, and drift checks.

## Implemented math mapping

- `getReverseClosure` computes the minimal impacted file set given a delta (transitive reverse deps).
- Test impact uses coverage and historical failure counts to produce a scoring of tests for changed files.
- Cache keys generated by `fileCompositeKey` mix content, config, tool version, and dependency signature.

## Running tests

Run the usual project commands:

```
npm ci
npm test
```

This runs the TypeScript build and the jest unit/property-based tests implemented.

## Next steps

- Integrate this into an LSP server for real-time diagnostics (extend `src/lsp/` into a language server).
- Add ESLint custom rules for control-flow regressions and wire them into CI.
- Add baseline collection of run metrics and a tool for comparing metric deltas to detect non-functional drift.

If you'd like, I can continue by building an LSP server glue or adding an ESLint plugin to detect specific patterns and wire a real TIA pipeline into CI.
